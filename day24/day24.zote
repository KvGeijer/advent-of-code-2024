include!("stdlib");
include!("../aoc.zote");

// Part 2. Solved from clues generated by code at the bottom by hand
swaps := [
    'wss', 'wrm',
    'hwq', 'z22',
    'gbs', 'z29',
    'thm', 'z08',
];
swaps >> sort >> join(",") >> print;

(init_txt, conns_txt) := read("input.txt") >> split("\n\n") >> map(\>> split("\n"));
initial := init_txt >> map(\>> split(": ") >> \(key, val) -> [key, val == "1"]) >> dict;
connections := conns_txt >> map(\>> split(" -> ") >> \(expr, res) -> [res, expr >> split(' ')]) >> dict; 

// for (x, y) in zip(swaps, swaps[1::]) (connections[x], connections[y]) = [connections[y], connections[x]];

blockers := union(initial, connections) >> map(\(k, _) -> [k, []]) >> dict;
for (unblock, (x, _, y)) in connections
    for blocker in [x, y]
        push(unblock, blockers[blocker]);

// Evaluates the final state of all wires, using a dfs search on unblocked calculations
fn eval(conns, init) -> {
    state := init >> clone;

    for key in init >> keys for unblocked in blockers[key] if !in(unblocked, state) {
        dfs(unblocked, conns, state);
    }
    state
}

fn dfs(wire, conns, state) -> {
    // We know the wire is not calculated already, but not that it is ready
    (x, op, y) := conns[wire];
    if !in(x, state) or !in(y, state) return;

    state[wire] = match op {
        "OR" -> state[x] or state[y],
        "AND" -> state[x] and state[y],
        "XOR" -> state[x] != state[y],
    };
    for unblocked in blockers[wire] if !in(unblocked, state)
        dfs(unblocked, conns, state);
}

fn get_nbr(state, char) -> {
    state >> list >> filter(\(k, _) -> k[0] == char) >> sort >> rev >> map(\>> [1]) >> foldl(0, \acc, v -> acc*2 + v)    
}

eval(connections, initial) >> get_nbr('z') >> print;

// How would one do addition over two numbers with these gates?
// x and y have 44 bits, and z has 45 bits.

fn get_name(char, nbr) -> char ++ if nbr < 10 '0' ++ str(nbr) else str(nbr);

// Part 2
last_and := nil;
last_xor := nil;

for nbr in [0:45] {
    if nbr == 0 continue; // Seems correct
    xn := get_name('x', nbr);
    yn := get_name('y', nbr);
    zn := get_name('z', nbr);

    // Always the same dependencies at least
    if blockers[xn] >> sort >> neq(blockers[yn] >> sort) print("strange at ", xn, " ", yn);

    // Always one and two deps?
    if blockers[xn] >> map(\b -> blockers[b] >> len) >> sort >> neq([1, 2]) {print("length strange at ", xn); last_and = last_xor = nil; continue };

    (and_out, xor_out) := blockers[xn] >> map(\b -> [blockers[b] >> len, b]) >> sort >> map(\>>[1]);
    if connections[xor_out][1] != "XOR" { print("Should be XOR at ", xn)}
    if connections[and_out][1] != "AND" { print("Should be AND at ", xn); last_xor = and_out; last_and = xor_out; continue };

    // Now check if they have the nice carried dep
    // first, does the xor lead to a z?
    if !in(zn, blockers[xor_out]) {print("Can't find z in xor out at ", xn); last_xor = xor_out; last_and = and_out; continue};

    // Then, what is the other? It should be included in the and recipe
    other_xor := connections[zn] >> filter(\>> [0] >> in('xyz') >> neq(xor_out)) >> [0];
    if blockers[xor_out] >> sort >> neq(blockers[other_xor] >> sort) print("xor outs not matched ", xn, " ", yn);
    if blockers[xor_out] >> map(\b -> connections[b][1]) >> sort >> neq(["AND", "XOR"]) {print("not right operands from xor")};
    
    // Now check that the dependency is actually carried to the next z
    if nbr < 44 and !in(get_name('z', nbr+1), blockers[blockers[and_out][0]]) {print("Carry not leading to next z at ", xn)};

    // Check that the operatoins are right in other places?
    if nbr < 44 and connections[zn][1] != 'XOR' print("Wrong operation for finding z at ", xn);    
    
    last_xor = xor_out;
    last_and = and_out;
}


// SWAPS:
// 1: Swap AND/XOR gate outputs on 14
//        wss and wrm
// 2: Swap hwq and z22
// 3: Swap gbs and z29
//
// Notes:
// y22 AND x22 -> z22
// x22 XOR y22 -> cdf
    // cdf AND cmn -> knw
    // cmn XOR cdf -> hwq    should be z22
    // 
// y29 XOR x29 -> bfq
    // bfq XOR dcf -> gbs         dcf should be used in two places, like this. What about bfq? Maybe bfq <-> z29. Yes!
        // y28 AND x28 -> rhg
        // pdq OR rhg -> dcf      looks right, output should be carried to next level
    // bfq AND dcf -> rpq
// x44 AND y44 -> fpg          fpg not leading to z. I guess this can be right so late..
    // fpg OR dqg -> z45
// vqp AND frr -> z08
// 

